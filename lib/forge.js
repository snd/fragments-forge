// Generated by CoffeeScript 1.9.1
var slice = [].slice;

module.exports.coerceToArray = function(arg) {
  if (Array.isArray(arg)) {
    return arg;
  }
  if (arg == null) {
    return [];
  }
  return [arg];
};

module.exports.uppercaseFirstLetter = function(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
};

module.exports.lowercaseFirstLetter = function(string) {
  return string.charAt(0).toLowerCase() + string.slice(1);
};

module.exports.splitCamelcase = function(string) {
  return string.match(/([A-Z]?[^A-Z]*)/g).slice(0, -1).map(function(x) {
    return x.toLowerCase();
  });
};

module.exports.joinCamelcase = function(array) {
  var capitalize;
  capitalize = function(string) {
    return module.exports.uppercaseFirstLetter(string.toLowerCase());
  };
  return module.exports.lowercaseFirstLetter(array.map(capitalize).join(''));
};

module.exports.joinUnderscore = function(array) {
  return array.join('_');
};

module.exports.findIndex = function(array, predicate) {
  var i, length;
  i = 0;
  length = array.length;
  while (i < length) {
    if (predicate(array[i])) {
      return i;
    }
    i++;
  }
  return -1;
};

module.exports.splitArray = function(array, value) {
  var currentPartition, i, length, matchingSequence, partitions, splitSequence;
  splitSequence = module.exports.coerceToArray(value);
  partitions = [];
  currentPartition = [];
  i = 0;
  length = array.length;
  matchingSequence = [];
  while (i < length) {
    if (array[i] === splitSequence[matchingSequence.length]) {
      matchingSequence.push(value[matchingSequence.length]);
      if (splitSequence.length === matchingSequence.length) {
        partitions.push(currentPartition);
        currentPartition = [];
        matchingSequence = [];
      }
    } else {
      if (matchingSequence.length !== 0) {
        currentPartition = currentPartition.concat(matchingSequence);
        matchingSequence = [];
      }
      currentPartition.push(array[i]);
    }
    i++;
  }
  if (matchingSequence.length !== 0) {
    currentPartition = currentPartition.concat(matchingSequence);
  }
  partitions.push(currentPartition);
  return partitions;
};

module.exports.splitWith = function(array, predicate) {
  var index;
  index = module.exports.findIndex(array, predicate);
  if (index === -1) {
    return [array, []];
  }
  return [array.slice(0, index), array.slice(index)];
};

module.exports.reverseIndex = function(index) {
  var reverseIndex;
  reverseIndex = {};
  Object.keys(index).forEach(function(key) {
    var value;
    value = index[key];
    if ('string' !== typeof value) {
      throw Error('all keys in index must map to a string');
    }
    if (reverseIndex[value] == null) {
      reverseIndex[value] = [];
    }
    return reverseIndex[value].push(key);
  });
  return reverseIndex;
};

module.exports.parseEnvSpec = function(name, flag) {
  var envVarName, maybe, type, varName, varWords, words;
  if (flag == null) {
    flag = 'env';
  }
  words = module.exports.splitCamelcase(name);
  if (words[0] !== flag) {
    return;
  }
  maybe = words[1] === 'maybe';
  type = words[maybe ? 2 : 1];
  if (type !== 'string' && type !== 'bool' && type !== 'int' && type !== 'float' && type !== 'json') {
    return;
  }
  varWords = words.slice(maybe ? 3 : 2);
  if (varWords.length === 0) {
    return;
  }
  varName = module.exports.joinCamelcase(varWords);
  envVarName = varWords.map(function(x) {
    return x.toUpperCase();
  }).join('_');
  return {
    maybe: maybe,
    type: type,
    name: varName,
    envVarName: envVarName
  };
};

module.exports.newEnvResolver = function(flag) {
  var resolver;
  resolver = function(name, container, inner) {
    var factory, result, spec;
    result = inner(name);
    if (result != null) {
      return result;
    }
    spec = module.exports.parseEnvSpec(name, flag);
    if (spec == null) {
      return;
    }
    factory = function(env) {
      var e, value;
      value = env[spec.envVarName];
      if ((value == null) || value === '') {
        if (spec.maybe) {
          return null;
        } else {
          throw new Error("env var " + spec.envVarName + " must not be blank");
        }
      }
      switch (spec.type) {
        case 'string':
          return value;
        case 'bool':
          if (value !== 'true' && value !== 'false') {
            throw new Error("env var " + spec.envVarName + " must be 'true' or 'false'");
          }
          return value === 'true';
        case 'int':
          result = parseInt(value, 10);
          if (isNaN(result)) {
            throw new Error("env var " + spec.envVarName + " must be an integer");
          }
          return result;
        case 'float':
          result = parseFloat(value);
          if (isNaN(result)) {
            throw new Error("env var " + spec.envVarName + " must be a float");
          }
          return result;
        case 'json':
          try {
            result = JSON.parse(value);
          } catch (_error) {
            e = _error;
            throw new Error("env var " + spec.envVarName + " must be json. syntax error: " + e.message);
          }
          return result;
      }
    };
    factory.$source = 'autogenerated by fragments-forge.newEnvResolver';
    factory.$match = spec;
    return {
      name: name,
      factory: factory
    };
  };
  resolver.$name = 'envResolver';
  return resolver;
};

module.exports.newTableResolver = function() {
  var resolver;
  resolver = function(name, container, inner) {
    var factory, result, tableName, words;
    result = inner(name);
    if (result != null) {
      return result;
    }
    words = module.exports.splitCamelcase(name);
    if (words[words.length - 1] !== 'table') {
      return;
    }
    if (!(words.length > 1)) {
      return;
    }
    tableName = module.exports.joinUnderscore(words.slice(0, words.length - 1));
    factory = function(mesa) {
      return mesa.table(tableName);
    };
    factory.$inject = ['mesa'];
    factory.$source = 'autogenerated by fragments-forge.newTableResolver';
    return {
      factory: factory,
      name: name
    };
  };
  resolver.$name = 'tableResolver';
  return resolver;
};

module.exports.newTableObjectResolver = function() {
  var resolver;
  resolver = function(name, container, inner) {
    var factory, result, tableName, words;
    result = inner(name);
    if (result != null) {
      return result;
    }
    words = module.exports.splitCamelcase(name);
    if (words[words.length - 1] !== 'table') {
      return;
    }
    if (!(words.length > 1)) {
      return;
    }
    tableName = module.exports.joinCamelcase(words.slice(0, words.length - 1));
    factory = function(table) {
      return table[tableName];
    };
    factory.$inject = ['table'];
    factory.$source = 'autogenerated by fragments-forge.newTableObjectResolver';
    return {
      factory: factory,
      name: name
    };
  };
  resolver.$name = 'tableObjectResolver';
  return resolver;
};

module.exports.parseDataSelect = function(name) {
  var order, orderProcessed, ref, ref1, ref2, table, tableWhere, tableWhereOrder, tableWhereOrderConnection, type, where, whereProcessed, withConnection, words;
  words = module.exports.splitCamelcase(name);
  type = words[0];
  if (type !== 'first' && type !== 'select') {
    return;
  }
  tableWhereOrderConnection = words.slice(1);
  ref = module.exports.splitArray(tableWhereOrderConnection, ['with', 'connection']), tableWhereOrder = ref[0], withConnection = ref[1];
  ref1 = module.exports.splitArray(tableWhereOrder, ['order', 'by']), tableWhere = ref1[0], order = 2 <= ref1.length ? slice.call(ref1, 1) : [];
  ref2 = module.exports.splitArray(tableWhere, 'where'), table = ref2[0], where = 2 <= ref2.length ? slice.call(ref2, 1) : [];
  if (table.length === 0) {
    return;
  }
  whereProcessed = where.filter(function(x) {
    return x.length !== 0;
  }).map(module.exports.joinUnderscore);
  orderProcessed = order.filter(function(x) {
    return x.length !== 0;
  }).map(function(x) {
    var column, direction, last;
    last = x[x.length - 1];
    if (last === 'asc' || last === 'desc') {
      column = x.slice(0, -1);
      direction = last.toUpperCase();
    } else {
      column = x;
      direction = 'ASC';
    }
    return {
      column: module.exports.joinUnderscore(column),
      direction: direction
    };
  });
  return {
    type: type,
    name: module.exports.joinCamelcase(table),
    order: orderProcessed,
    where: whereProcessed,
    withConnection: withConnection != null
  };
};

module.exports.newDataFirstResolver = function(options) {
  var resolver;
  if (options == null) {
    options = {};
  }
  if (options.matcher == null) {
    options.matcher = module.exports.parseDataSelect;
  }
  if (options.nameToTable == null) {
    options.nameToTable = function(name) {
      return name + 'Table';
    };
  }
  resolver = function(name, container, inner) {
    var factory, match, result;
    result = inner(name);
    if (result != null) {
      return result;
    }
    match = options.matcher(name);
    if (!((match != null) && match.type === 'first')) {
      return;
    }
    factory = function(table) {
      return function() {
        var args, connection, index, order, query;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        query = table;
        index = 0;
        match.where.forEach(function(x) {
          var condition;
          condition = {};
          condition[x] = args[index++];
          return query = query.where(condition);
        });
        if (match.order.length !== 0) {
          order = match.order.map(function(x) {
            return x.column + ' ' + x.direction;
          }).join(', ');
          query = query.order(order);
        }
        if (match.withConnection) {
          connection = args[index];
          if (connection == null) {
            throw new Error(name + " must be called with connection as argument number " + (index + 1));
          }
          query = query.setConnection(connection);
        }
        return query.first();
      };
    };
    factory.$inject = [options.nameToTable(match.name)];
    factory.$source = 'autogenerated by fragments-forge.newDataFirstResolver';
    factory.$match = match;
    return {
      factory: factory,
      name: name
    };
  };
  resolver.$name = 'dataFirstResolver';
  return resolver;
};

module.exports.newDataSelectResolver = function(options) {
  var resolver;
  if (options == null) {
    options = {};
  }
  if (options.matcher == null) {
    options.matcher = module.exports.parseDataSelect;
  }
  if (options.nameToTable == null) {
    options.nameToTable = function(name) {
      return name + 'Table';
    };
  }
  resolver = function(name, container, inner) {
    var factory, match, result;
    result = inner(name);
    if (result != null) {
      return result;
    }
    match = options.matcher(name);
    if (!((match != null) && match.type === 'select')) {
      return;
      return;
    }
    factory = function(table) {
      return function() {
        var args, connection, index, order, q;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        q = table;
        index = 0;
        match.where.forEach(function(x) {
          var condition;
          condition = {};
          condition[x] = args[index++];
          return q = q.where(condition);
        });
        if (match.order.length !== 0) {
          order = match.order.map(function(x) {
            return x.column + ' ' + x.direction;
          }).join(', ');
          q = q.order(order);
        }
        if (match.withConnection) {
          connection = args[index];
          if (connection == null) {
            throw new Error(name + " must be called with connection as argument number " + (index + 1));
          }
          q = q.setConnection(connection);
        }
        return q.find();
      };
    };
    factory.$inject = [options.nameToTable(match.name)];
    factory.$source = 'autogenerated by fragments-forge.newDataSelectResolver';
    factory.$match = match;
    return {
      factory: factory,
      name: name
    };
  };
  resolver.$name = 'dataSelectResolver';
  return resolver;
};

module.exports.parseDataInsert = function(name) {
  var ref, table, withConnection, words;
  words = module.exports.splitCamelcase(name);
  if ('insert' !== words[0]) {
    return;
  }
  ref = module.exports.splitArray(words.slice(1), ['with', 'connection']), table = ref[0], withConnection = ref[1];
  if (table.length === 0) {
    return;
  }
  return {
    name: module.exports.joinCamelcase(table),
    withConnection: withConnection != null
  };
};

module.exports.newDataInsertResolver = function(options) {
  var resolver;
  if (options == null) {
    options = {};
  }
  if (options.matcher == null) {
    options.matcher = module.exports.parseDataInsert;
  }
  if (options.nameToTable == null) {
    options.nameToTable = function(name) {
      return name + 'Table';
    };
  }
  if (options.nameToAllowedColumns == null) {
    options.nameToAllowedColumns = function(name) {
      return name + 'InsertableColumns';
    };
  }
  resolver = function(name, container, inner) {
    var factory, match, result;
    result = inner(name);
    if (result != null) {
      return result;
    }
    match = options.matcher(name);
    if (match == null) {
      return;
    }
    factory = function(table, allowedColumns) {
      return function(data, connection) {
        var query;
        query = table;
        if (match.withConnection) {
          if (connection == null) {
            throw new Error(name + " must be called with connection as argument number " + (index + 1));
          }
          query = query.setConnection(connection);
        }
        return query.allow(allowedColumns).insert(data);
      };
    };
    factory.$inject = [options.nameToTable(match.name), options.nameToAllowedColumns(match.name)];
    factory.$source = 'autogenerated by fragments-forge.newDataInsertResolver';
    factory.$match = match;
    return {
      factory: factory,
      name: name
    };
  };
  resolver.$name = 'dataInsertResolver';
  return resolver;
};

module.exports.parseDataUpdate = function(name) {
  var ref, ref1, table, tableWhere, where, withConnection, words;
  words = module.exports.splitCamelcase(name);
  if ('update' !== words[0]) {
    return;
  }
  ref = module.exports.splitArray(words.slice(1), ['with', 'connection']), tableWhere = ref[0], withConnection = ref[1];
  ref1 = module.exports.splitArray(tableWhere, 'where'), table = ref1[0], where = 2 <= ref1.length ? slice.call(ref1, 1) : [];
  if (table.length === 0) {
    return;
  }
  if (where.length === 0) {
    return;
  }
  return {
    name: module.exports.joinCamelcase(table),
    where: where.map(function(x) {
      return module.exports.joinUnderscore(x);
    }),
    withConnection: withConnection != null
  };
};

module.exports.newDataUpdateResolver = function(options) {
  var resolver;
  if (options == null) {
    options = {};
  }
  if (options.matcher == null) {
    options.matcher = module.exports.parseDataUpdate;
  }
  if (options.nameToTable == null) {
    options.nameToTable = function(name) {
      return name + 'Table';
    };
  }
  if (options.nameToAllowedColumns == null) {
    options.nameToAllowedColumns = function(name) {
      return name + 'UpdateableColumns';
    };
  }
  resolver = function(name, container, inner) {
    var factory, match, result;
    result = inner(name);
    if (result != null) {
      return result;
    }
    match = options.matcher(name);
    if (match == null) {
      return;
    }
    factory = function(table, allowedColumns) {
      return function() {
        var args, connection, data, index, query;
        data = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        query = table;
        index = 0;
        match.where.forEach(function(x) {
          var condition;
          condition = {};
          condition[x] = args[index++];
          return query = query.where(condition);
        });
        if (match.withConnection) {
          connection = args[index];
          if (connection == null) {
            throw new Error(name + " must be called with connection as argument number " + (index + 1));
          }
          query = query.setConnection(connection);
        }
        return query.allow(allowedColumns).update(data);
      };
    };
    factory.$inject = [options.nameToTable(match.name), options.nameToAllowedColumns(match.name)];
    factory.$source = 'autogenerated by fragments-forge.newDataUpdateResolver';
    factory.$match = match;
    return {
      factory: factory,
      name: name
    };
  };
  resolver.$name = 'dataUpdateResolver';
  return resolver;
};

module.exports.parseDataDelete = function(name) {
  var ref, ref1, table, tableWhere, where, withConnection, words;
  words = module.exports.splitCamelcase(name);
  if ('delete' !== words[0]) {
    return;
  }
  ref = module.exports.splitArray(words.slice(1), ['with', 'connection']), tableWhere = ref[0], withConnection = ref[1];
  ref1 = module.exports.splitArray(tableWhere, 'where'), table = ref1[0], where = 2 <= ref1.length ? slice.call(ref1, 1) : [];
  if (table.length === 0) {
    return;
  }
  if (where.length === 0) {
    return;
  }
  return {
    name: module.exports.joinCamelcase(table),
    where: where.map(function(x) {
      return module.exports.joinUnderscore(x);
    }),
    withConnection: withConnection != null
  };
};

module.exports.newDataDeleteResolver = function(options) {
  var resolver;
  if (options == null) {
    options = {};
  }
  if (options.matcher == null) {
    options.matcher = module.exports.parseDataDelete;
  }
  if (options.nameToTable == null) {
    options.nameToTable = function(name) {
      return name + 'Table';
    };
  }
  resolver = function(name, container, inner) {
    var factory, match, result;
    result = inner(name);
    if (result != null) {
      return result;
    }
    match = options.matcher(name);
    if (match == null) {
      return;
    }
    factory = function(table) {
      return function() {
        var args, connection, index, query;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        query = table;
        index = 0;
        match.where.forEach(function(x) {
          var condition;
          condition = {};
          condition[x] = args[index++];
          return query = query.where(condition);
        });
        if (match.withConnection) {
          connection = args[index];
          if (connection == null) {
            throw new Error(name + " must be called with connection as argument number " + (index + 1));
          }
          query = query.setConnection(connection);
        }
        return query["delete"]();
      };
    };
    factory.$inject = [options.nameToTable(match.name)];
    factory.$source = 'autogenerated by fragments-forge.newDataDeleteResolver';
    factory.$match = match;
    return {
      factory: factory,
      name: name
    };
  };
  resolver.$name = 'dataDeleteResolver';
  return resolver;
};

module.exports.newAliasResolver = function(aliasMap) {
  var resolver;
  if (aliasMap == null) {
    aliasMap = {};
  }
  resolver = function(name, container, inner) {
    var alias, result;
    result = inner(name);
    if (result != null) {
      return result;
    }
    alias = aliasMap[name];
    if (alias == null) {
      return;
    }
    return inner(alias);
  };
  resolver.$name = 'aliasResolver';
  return resolver;
};

module.exports.newNamespaceResolver = function(aliasToNamespaces) {
  var resolver;
  if (aliasToNamespaces == null) {
    aliasToNamespaces = {};
  }
  resolver = function(name, container, inner) {
    var aliasPart, fn, j, len, lines, namePart, namespace, parts, possibleNamespaces, results, value;
    value = inner(name);
    if (value != null) {
      return value;
    }
    parts = name.split('_');
    if (parts.length === 1) {
      aliasPart = '';
      namePart = parts[0];
    } else {
      aliasPart = parts.slice(0, -1).join('_');
      namePart = parts[parts.length - 1];
    }
    possibleNamespaces = aliasToNamespaces[aliasPart];
    if (possibleNamespaces == null) {
      return;
    }
    if (!Array.isArray(possibleNamespaces)) {
      throw new Error('values in aliasToNamespaces must be arrays');
    }
    results = [];
    fn = function(namespace) {
      var mappedName, resolved;
      mappedName = namespace === '' ? namePart : [namespace, namePart].join('_');
      resolved = inner(mappedName);
      if (resolved != null) {
        return results.push({
          namespace: namespace,
          mappedName: mappedName,
          resolved: resolved
        });
      }
    };
    for (j = 0, len = possibleNamespaces.length; j < len; j++) {
      namespace = possibleNamespaces[j];
      fn(namespace);
    }
    switch (results.length) {
      case 0:
        return void 0;
      case 1:
        return results[0].resolved;
      default:
        lines = ["ambiguity in namespace resolver.", "\"" + name + "\" maps to multiple resolvable names:"];
        results.forEach(function(result) {
          return lines.push(result.mappedName + " (" + aliasPart + " -> " + result.namespace + ")");
        });
        throw new Error(lines.join('\n'));
    }
  };
  resolver.$name = 'namespaceResolver';
  return resolver;
};
