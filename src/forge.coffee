###################################################################################
# util

module.exports.coerceToArray = (arg) ->
  if Array.isArray arg
    return arg
  unless arg?
    return []
  [arg]

module.exports.uppercaseFirstLetter = (string) ->
  string.charAt(0).toUpperCase() + string.slice(1)

module.exports.lowercaseFirstLetter = (string) ->
  string.charAt(0).toLowerCase() + string.slice(1)

# splitCamelcase 'oneTwoThree' => ['one', 'two', 'three']
module.exports.splitCamelcase = (string) ->
  string.match(/([A-Z]?[^A-Z]*)/g).slice(0,-1).map (x) ->
    x.toLowerCase()

# joinCamelcase ['One', 'two', 'three'] => 'oneTwoThree'
module.exports.joinCamelcase = (array) ->
  capitalize = (string) ->
    module.exports.uppercaseFirstLetter string.toLowerCase()
  module.exports.lowercaseFirstLetter array.map(capitalize).join('')

# joinUnderscore ['one', 'two', 'three'] => 'one_two_three'
module.exports.joinUnderscore = (array) ->
  array.join('_')

# find the index of the first array element for which predicate returns true
# otherwise returns -1
module.exports.findIndex = (array, predicate) ->
  i = 0
  length = array.length
  while i < length
    if predicate array[i]
        return i
    i++
  return -1

module.exports.splitArray = (array, value) ->
  splitSequence = module.exports.coerceToArray value
  partitions = []
  currentPartition = []
  i = 0
  length = array.length
  matchingSequence = []
  while i < length
    # matching so far
    if array[i] is splitSequence[matchingSequence.length]
      matchingSequence.push value[matchingSequence.length]
      # complete match
      if splitSequence.length is matchingSequence.length
        partitions.push currentPartition
        currentPartition = []
        matchingSequence = []
    # not matching
    else
      # no longer matching
      if matchingSequence.length isnt 0
        currentPartition = currentPartition.concat(matchingSequence)
        matchingSequence = []
      currentPartition.push array[i]
    i++
  if matchingSequence.length isnt 0
    currentPartition = currentPartition.concat(matchingSequence)
  partitions.push currentPartition
  partitions

# split array into two parts:
# the first part contains all elements up to (but not including)
# the first element for which predicate returned true.
# the second part contains all elements from (and including)
# the first element for which preducate returned true.
module.exports.splitWith = (array, predicate) ->
  index = module.exports.findIndex array, predicate
  if index is -1
    return [array, []]
  [array.slice(0, index), array.slice(index)]

module.exports.reverseIndex = (index) ->
  reverseIndex = {}
  Object.keys(index).forEach (key) ->
    value = index[key]
    unless 'string' is typeof value
      throw Error 'all keys in index must map to a string'
    reverseIndex[value] ?= []
    reverseIndex[value].push key
  return reverseIndex

###################################################################################
# env

module.exports.parseEnvSpec = (name, flagPrefix = 'env') ->
  words = module.exports.splitCamelcase name

  unless words[0] is flagPrefix
    return

  maybe = words[1] is 'maybe'

  type = words[if maybe then 2 else 1]

  unless type in ['string', 'bool', 'int', 'float', 'json']
    return

  varWords = words.slice if maybe then 3 else 2

  if varWords.length is 0
    return

  varName = module.exports.joinCamelcase varWords
  envVarName = varWords.map((x) -> x.toUpperCase()).join('_')

  {
    maybe: maybe
    type: type
    name: varName
    envVarName: envVarName
  }

module.exports.newEnvResolver = (flagPrefix) ->
  resolver = (query, inner) ->
    result = inner query
    # we dont need to do anything
    if result?
      return result

    name = query.path[0]

    spec = module.exports.parseEnvSpec name, flagPrefix

    # we cant do anything
    unless spec?
      return

    factory = (env) ->
      value = env[spec.envVarName]
      if not value? or value is''
        if spec.maybe
          return null
        else
          throw new Error "env var #{spec.envVarName} must not be blank"

      switch spec.type
        when 'string'
          value
        when 'bool'
          unless value in ['true', 'false']
            throw new Error "env var #{spec.envVarName} must be 'true' or 'false'"
          value is 'true'
        when 'int'
          result = parseInt value, 10
          if isNaN result
            throw new Error "env var #{spec.envVarName} must be an integer"
          result
        when 'float'
          result = parseFloat value
          if isNaN result
            throw new Error "env var #{spec.envVarName} must be a float"
          result
        when 'json'
          try
            result = JSON.parse value
          catch e
            throw new Error "env var #{spec.envVarName} must be json. syntax error: #{e.message}"
          result

    factory.$source = 'autogenerated by blaze-forge.newEnvResolver'
    factory.$match = spec

    return {
      path: query.path
      factory: factory
      container: query.container
    }

  resolver.$name = 'envResolver'
  return resolver

###################################################################################
# table

module.exports.newTableResolver = ->
  resolver = (query, inner) ->
    result = inner query
    if result?
      return result

    words = module.exports.splitCamelcase query.path[0]

    unless words[words.length - 1] is 'table'
      return

    unless words.length > 1
      return

    tableName = module.exports.joinCamelcase words.slice(0, words.length - 1)

    factory = (table) ->
      table[tableName]

    factory.$inject = ['table']
    factory.$source = 'autogenerated by blaze-forge.newTableResolver'

    return {
      factory: factory
      path: query.path
      container: query.container
    }

  resolver.$name = 'tableResolver'
  return resolver

###################################################################################
# alias

module.exports.newAliasResolver = (aliasMap = {}) ->
  resolver = (query, inner) ->
    result = inner query
    if result?
      return result

    alias = aliasMap[query.path[0]]

    unless alias?
      return

    newPath = query.path.slice()
    newPath[0] = alias

    inner
      path: newPath
      container: query.container

  resolver.$name = 'aliasResolver'
  return resolver

###################################################################################
# parse data select

module.exports.parseDataSelect = (name) ->
  words = module.exports.splitCamelcase name

  type = words[0]

  unless type in ['first', 'select']
    return

  tableAndWhereAndOrder = words.slice(1)

  tableAndWhere = tableAndWhereAndOrder
  [tableAndWhere, order...] = module.exports.splitArray tableAndWhereAndOrder,
    ['order', 'by']

  [table, where...] = module.exports.splitArray tableAndWhere, 'where'

  whereProcessed = where
    .filter (x) -> x.length isnt 0
    .map module.exports.joinUnderscore

  orderProcessed = order
    .filter (x) -> x.length isnt 0
    .map (x) ->
      last = x[x.length - 1]
      if last in ['asc', 'desc']
        column = x.slice(0, -1)
        direction = last.toUpperCase()
      else
        column = x
        direction = 'ASC'
      {
        column: module.exports.joinUnderscore column
        direction: direction
      }

  {
    type: type
    name: module.exports.joinCamelcase table
    order: orderProcessed
    where: whereProcessed
  }

###################################################################################
# data first

module.exports.newDataFirstResolver = (options = {}) ->
  options.matcher ?= module.exports.parseDataSelect
  options.nameToTable ?= (name) ->
    name + 'Table'

  resolver = (query, inner) ->
    result = inner query
    if result?
      return result

    match = options.matcher query.path[0]
    unless match? and match.type is 'first'
      return

    factory = (table) ->
      (args...) ->
        q = table
        match.where.forEach (x, index) ->
          condition = {}
          condition[x] = args[index]
          q = q.where condition
        if match.order.length isnt 0
          order = match.order
            .map (x) ->
              x.column + ' ' + x.direction
            .join (', ')
          q = q.order order

        q.first()

    factory.$inject = [
      options.nameToTable(match.name)
    ]
    factory.$source = 'autogenerated by blaze-forge.newDataFirstResolver'
    factory.$match = match

    return {
      factory: factory
      path: query.path
      container: query.container
    }

  resolver.$name = 'dataFirstResolver'
  return resolver

###################################################################################
# data select

module.exports.newDataSelectResolver = (options = {}) ->
  options.matcher ?= module.exports.parseDataSelect
  options.nameToTable ?= (name) ->
    name + 'Table'

  resolver = (query, inner) ->
    result = inner query
    # we dont need to do anything
    if result?
      return result

    match = options.matcher query.path[0]
    # we cant do anything
    unless match? and match.type is 'select'
      return
      return

    factory = (table) ->
      (args...) ->
        q = table
        match.where.forEach (x, index) ->
          condition = {}
          condition[x] = args[index]
          q = q.where condition
        if match.order.length isnt 0
          order = match.order
            .map (x) ->
              x.column + ' ' + x.direction
            .join (', ')
          q = q.order order
        q.find()

    factory.$inject = [
      options.nameToTable(match.name)
    ]
    factory.$source = 'autogenerated by blaze-forge.newDataSelectResolver'
    factory.$match = match

    return {
      factory: factory
      container: query.container
      path: query.path
    }

  resolver.$name = 'dataSelectResolver'
  return resolver

###################################################################################
# data insert

module.exports.parseDataInsert = (name) ->
  words = module.exports.splitCamelcase name

  unless 'insert' is words[0]
    return

  {
    name: module.exports.joinCamelcase(words.slice(1))
  }

module.exports.newDataInsertResolver = (options = {}) ->
  options.matcher ?= module.exports.parseDataInsert
  options.nameToTable ?= (name) ->
    name + 'Table'
  # options.nameToAllowedColumns ?= (name) ->
  #   name + 'Columns'

  resolver = (query, inner) ->
    result = inner query
    if result?
      return result

    match = options.matcher query.path[0]
    unless match?
      return

    factory = (table, allowedColumns) ->
      (data) ->
        table
          # .allowedColumns(allowedColumns)
          .insert(data)

    factory.$inject = [
      options.nameToTable(match.name)
      # options.nameToAllowedColumns(match.name)
    ]
    factory.$source = 'autogenerated by blaze-forge.newDataInsertResolver'
    factory.$match = match

    return {
      factory: factory
      path: query.path
      container: query.container
    }

  resolver.$name = 'dataInsertResolver'
  return resolver

###################################################################################
# data update

module.exports.parseDataUpdate = (name) ->
  words = module.exports.splitCamelcase name

  unless 'update' is words[0]
    return

  rest = words.slice(1)

  partition = module.exports.splitArray rest, 'where'

  # dont allow mass update without condition for security reasons
  if partition.length is 1
    return

  {
    name: module.exports.joinCamelcase partition[0]
    where: partition.slice(1).map (x) -> module.exports.joinUnderscore x
  }

module.exports.newDataUpdateResolver = (options = {}) ->
  options.matcher ?= module.exports.parseDataUpdate
  options.nameToTable ?= (name) ->
    name + 'Table'
  # options.nameToAllowedColumns ?= (name) ->
  #   name + 'Columns'

  resolver = (query, inner) ->
    result = inner query
    if result?
      return result

    match = options.matcher query.path[0]
    unless match?
      return

    factory = (table, allowedColumns) ->
      (data, args...) ->
        query = table
        match.where.forEach (x, index) ->
          condition = {}
          condition[x] = args[index]
          query = query.where condition
        query
          # .allowedColumns(allowedColumns)
          .update(data)

    factory.$inject = [
      options.nameToTable(match.name)
      # options.nameToAllowedColumns(match.name)
    ]
    factory.$source = 'autogenerated by blaze-forge.newDataUpdateResolver'
    factory.$match = match

    return {
      factory: factory
      path: query.path
      container: query.container
    }

  resolver.$name = 'dataUpdateResolver'
  return resolver

###################################################################################
# data delete

module.exports.parseDataDelete = (name) ->
  words = module.exports.splitCamelcase name

  unless 'delete' is words[0]
    return

  rest = words.slice(1)

  partition = module.exports.splitArray rest, 'where'

  # dont allow mass delete without condition for security reasons
  if partition.length is 1
    return

  {
    name: module.exports.joinCamelcase partition[0]
    where: partition.slice(1).map (x) -> module.exports.joinUnderscore x
  }

module.exports.newDataDeleteResolver = (options = {}) ->
  options.matcher ?= module.exports.parseDataDelete
  options.nameToTable ?= (name) ->
    name + 'Table'

  resolver = (query, inner) ->
    result = inner query
    if result?
      return result

    match = options.matcher query.path[0]
    unless match?
      return

    factory = (table) ->
      (args...) ->
        query = table
        match.where.forEach (x, index) ->
          condition = {}
          condition[x] = args[index]
          query = query.where condition
        query.delete()

    factory.$inject = [
      options.nameToTable(match.name)
    ]
    factory.$source = 'autogenerated by blaze-forge.newDataDeleteResolver'
    factory.$match = match

    return {
      factory: factory
      container: query.container
      path: query.path
    }

  resolver.$name = 'dataDeleteResolver'
  return resolver

###################################################################################
# namespace

module.exports.newNamespaceResolver = (aliasToNamespaces = {}) ->
  resolver = (query, inner) ->
    # if the name is directly resolvable return it
    value = inner query
    if value?
      return value

    # otherwise try out namespace mappings

    parts = query.path[0].split '_'
    if parts.length is 1
      # common case (no namespace part)
      aliasPart = ''
      namePart = parts[0]
    else
      aliasPart = parts.slice(0, -1).join('_')
      namePart = parts[parts.length - 1]

    possibleNamespaces = aliasToNamespaces[aliasPart]

    unless possibleNamespaces?
      # common case (no mapping for namespace part)
      return

    unless Array.isArray possibleNamespaces
      throw new Error 'values in aliasToNamespaces must be arrays'

    results = []

    for namespace in possibleNamespaces
      do (namespace) ->
        # call inner multiple times with different ids
        mappedName = if namespace is ''
            namePart
          else
            [namespace, namePart].join('_')
        newPath = query.path.slice()
        newPath[0] = mappedName
        resolved = inner
          container: query.container
          path: newPath
        if resolved?
          results.push
            namespace: namespace
            mappedName: mappedName
            resolved: resolved

    return switch results.length
      when 0 then undefined
      when 1 then results[0].resolved
      else
        lines = [
          "ambiguity in namespace resolver."
          "\"#{query.path[0]}\" maps to multiple resolvable names:"
        ]
        results.forEach (result) ->
          lines.push "#{result.mappedName} (#{aliasPart} -> #{result.namespace})"
        throw new Error lines.join('\n')

  resolver.$name = 'namespaceResolver'
  return resolver

###################################################################################
# custom

# transforms resolution based on who required it

module.exports.newMockResolver = (aliasToNamespaces = {}) ->
  resolver = (query, inner) ->
    # if the name is directly resolvable return it
    value = inner query
    if value?
      return value

    # otherwise try out namespace mappings

    parts = query.path[0].split '_'
    if parts.length is 1
      # common case (no namespace part)
      aliasPart = ''
      namePart = parts[0]
    else
      aliasPart = parts.slice(0, -1).join('_')
      namePart = parts[parts.length - 1]

    possibleNamespaces = aliasToNamespaces[aliasPart]

    unless possibleNamespaces?
      # common case (no mapping for namespace part)
      return

    unless Array.isArray possibleNamespaces
      throw new Error 'values in aliasToNamespaces must be arrays'

    results = []

    for namespace in possibleNamespaces
      do (namespace) ->
        # call inner multiple times with different ids
        mappedName = if namespace is ''
            namePart
          else
            [namespace, namePart].join('_')
        newPath = query.path.slice()
        newPath[0] = mappedName
        resolved = inner
          container: query.container
          path: newPath
        if resolved?
          results.push
            namespace: namespace
            mappedName: mappedName
            resolved: resolved

    return switch results.length
      when 0 then undefined
      when 1 then results[0].resolved
      else
        lines = [
          "ambiguity in namespace resolver."
          "\"name\" maps to multiple resolvable names:"
        ]
        results.forEach (result) ->
          lines.push "#{result.mappedName} (#{alias} -> #{result.namespace})"
        throw new Error lines.join('\n')

  resolver.$name = 'namespaceResolver'
  return resolver
