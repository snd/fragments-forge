###################################################################################
# util

module.exports.coerceToArray = (arg) ->
  if Array.isArray arg
    return arg
  unless arg?
    return []
  [arg]

module.exports.uppercaseFirstLetter = (string) ->
  string.charAt(0).toUpperCase() + string.slice(1)

module.exports.lowercaseFirstLetter = (string) ->
  string.charAt(0).toLowerCase() + string.slice(1)

# splitCamelcase 'oneTwoThree' => ['one', 'two', 'three']
module.exports.splitCamelcase = (string) ->
  string.match(/([A-Z]?[^A-Z]*)/g).slice(0,-1).map (x) ->
    x.toLowerCase()

# joinCamelcase ['One', 'two', 'three'] => 'oneTwoThree'
module.exports.joinCamelcase = (array) ->
  capitalize = (string) ->
    module.exports.uppercaseFirstLetter string.toLowerCase()
  module.exports.lowercaseFirstLetter array.map(capitalize).join('')

# joinUnderscore ['one', 'two', 'three'] => 'one_two_three'
module.exports.joinUnderscore = (array) ->
  array.join('_')

# find the index of the first array element for which predicate returns true
# otherwise returns -1
module.exports.findIndex = (array, predicate) ->
  i = 0
  length = array.length
  while i < length
    if predicate array[i]
        return i
    i++
  return -1

module.exports.splitArray = (array, value) ->
  splitSequence = module.exports.coerceToArray value
  partitions = []
  currentPartition = []
  i = 0
  length = array.length
  matchingSequence = []
  while i < length
    # matching so far
    if array[i] is splitSequence[matchingSequence.length]
      matchingSequence.push value[matchingSequence.length]
      # complete match
      if splitSequence.length is matchingSequence.length
        partitions.push currentPartition
        currentPartition = []
        matchingSequence = []
    # not matching
    else
      # no longer matching
      if matchingSequence.length isnt 0
        currentPartition = currentPartition.concat(matchingSequence)
        matchingSequence = []
      currentPartition.push array[i]
    i++
  if matchingSequence.length isnt 0
    currentPartition = currentPartition.concat(matchingSequence)
  partitions.push currentPartition
  partitions

# split array into two parts:
# the first part contains all elements up to (but not including)
# the first element for which predicate returned true.
# the second part contains all elements from (and including)
# the first element for which preducate returned true.
module.exports.splitWith = (array, predicate) ->
  index = module.exports.findIndex array, predicate
  if index is -1
    return [array, []]
  [array.slice(0, index), array.slice(index)]

module.exports.reverseIndex = (index) ->
  reverseIndex = {}
  Object.keys(index).forEach (key) ->
    value = index[key]
    unless 'string' is typeof value
      throw Error 'all keys in index must map to a string'
    reverseIndex[value] ?= []
    reverseIndex[value].push key
  return reverseIndex

###################################################################################
# env:
# envIntBcryptCost -> parse env var BCRYPT_COST as integer

module.exports.parseEnvSpec = (name, flag = 'env') ->
  words = module.exports.splitCamelcase name

  unless words[0] is flag
    return

  maybe = words[1] is 'maybe'

  type = words[if maybe then 2 else 1]

  unless type in ['string', 'bool', 'int', 'float', 'json']
    return

  varWords = words.slice if maybe then 3 else 2

  if varWords.length is 0
    return

  varName = module.exports.joinCamelcase varWords
  envVarName = varWords.map((x) -> x.toUpperCase()).join('_')

  {
    maybe: maybe
    type: type
    name: varName
    envVarName: envVarName
  }

module.exports.newEnvResolver = (flag) ->
  resolver = (name, container, inner) ->
    result = inner name
    # we dont need to do anything
    if result?
      return result

    spec = module.exports.parseEnvSpec name, flag

    # we cant do anything
    unless spec?
      return

    factory = (env) ->
      value = env[spec.envVarName]
      if not value? or value is''
        if spec.maybe
          return null
        else
          throw new Error "env var #{spec.envVarName} must not be blank"

      switch spec.type
        when 'string'
          value
        when 'bool'
          unless value in ['true', 'false']
            throw new Error "env var #{spec.envVarName} must be 'true' or 'false'"
          value is 'true'
        when 'int'
          result = parseInt value, 10
          if isNaN result
            throw new Error "env var #{spec.envVarName} must be an integer"
          result
        when 'float'
          result = parseFloat value
          if isNaN result
            throw new Error "env var #{spec.envVarName} must be a float"
          result
        when 'json'
          try
            result = JSON.parse value
          catch e
            throw new Error "env var #{spec.envVarName} must be json. syntax error: #{e.message}"
          result

    factory.$source = 'autogenerated by fragments-forge.newEnvResolver'
    factory.$match = spec

    return {
      name: name
      factory: factory
    }

  resolver.$name = 'envResolver'
  return resolver

###################################################################################
# table:
# userTable -> mesa.table('user')

module.exports.newTableResolver = ->
  resolver = (name, container, inner) ->
    result = inner name
    if result?
      return result

    words = module.exports.splitCamelcase name

    unless words[words.length - 1] is 'table'
      return

    unless words.length > 1
      return

    tableName = module.exports.joinUnderscore words.slice(0, words.length - 1)

    factory = (mesa) ->
      mesa.table(tableName)

    factory.$inject = ['mesa']
    factory.$source = 'autogenerated by fragments-forge.newTableResolver'

    return {
      factory: factory
      name: name
    }

  resolver.$name = 'tableResolver'
  return resolver

###################################################################################
# look up table in table object:
# userTable -> table.user

module.exports.newTableObjectResolver = ->
  resolver = (name, container, inner) ->
    result = inner name
    if result?
      return result

    words = module.exports.splitCamelcase name

    unless words[words.length - 1] is 'table'
      return

    unless words.length > 1
      return

    tableName = module.exports.joinCamelcase words.slice(0, words.length - 1)

    factory = (table) ->
      table[tableName]

    factory.$inject = ['table']
    factory.$source = 'autogenerated by fragments-forge.newTableObjectResolver'

    return {
      factory: factory
      name: name
    }

  resolver.$name = 'tableObjectResolver'
  return resolver

###################################################################################
# parse data select

module.exports.parseDataSelect = (name) ->
  words = module.exports.splitCamelcase name

  type = words[0]

  unless type in ['first', 'select']
    return

  tableWhereOrderConnection = words.slice(1)

  [tableWhereOrder, withConnection] = module.exports.splitArray(
    tableWhereOrderConnection
    ['with', 'connection']
  )

  [tableWhere, order...] = module.exports.splitArray(
    tableWhereOrder
    ['order', 'by']
  )

  [table, where...] = module.exports.splitArray tableWhere, 'where'

  if table.length is 0
    return

  whereProcessed = where
    .filter (x) -> x.length isnt 0
    .map module.exports.joinUnderscore

  orderProcessed = order
    .filter (x) -> x.length isnt 0
    .map (x) ->
      last = x[x.length - 1]
      if last in ['asc', 'desc']
        column = x.slice(0, -1)
        direction = last.toUpperCase()
      else
        column = x
        direction = 'ASC'
      {
        column: module.exports.joinUnderscore column
        direction: direction
      }

  {
    type: type
    name: module.exports.joinCamelcase table
    order: orderProcessed
    where: whereProcessed
    withConnection: withConnection?
  }

###################################################################################
# data first

module.exports.newDataFirstResolver = (options = {}) ->
  options.matcher ?= module.exports.parseDataSelect
  options.nameToTable ?= (name) ->
    name + 'Table'

  resolver = (name, container, inner) ->
    result = inner name
    if result?
      return result

    match = options.matcher name
    unless match? and match.type is 'first'
      return

    factory = (table) ->
      (args...) ->
        query = table
        index = 0
        match.where.forEach (x) ->
          condition = {}
          condition[x] = args[index++]
          query = query.where condition
        if match.order.length isnt 0
          order = match.order
            .map (x) ->
              x.column + ' ' + x.direction
            .join (', ')
          query = query.order order
        if match.withConnection
          connection = args[index]
          unless connection?
            throw new Error "#{name} must be called with connection as argument number #{index+1}"
          query = query.setConnection connection

        query.first()

    factory.$inject = [
      options.nameToTable(match.name)
    ]
    factory.$source = 'autogenerated by fragments-forge.newDataFirstResolver'
    factory.$match = match

    return {
      factory: factory
      name: name
    }

  resolver.$name = 'dataFirstResolver'
  return resolver

###################################################################################
# data select

module.exports.newDataSelectResolver = (options = {}) ->
  options.matcher ?= module.exports.parseDataSelect
  options.nameToTable ?= (name) ->
    name + 'Table'

  resolver = (name, container, inner) ->
    result = inner name
    # we dont need to do anything
    if result?
      return result

    match = options.matcher name
    # we cant do anything
    unless match? and match.type is 'select'
      return
      return

    factory = (table) ->
      (args...) ->
        q = table
        index = 0
        match.where.forEach (x) ->
          condition = {}
          condition[x] = args[index++]
          q = q.where condition
        if match.order.length isnt 0
          order = match.order
            .map (x) ->
              x.column + ' ' + x.direction
            .join (', ')
          q = q.order order
        if match.withConnection
          connection = args[index]
          unless connection?
            throw new Error "#{name} must be called with connection as argument number #{index+1}"
          q = q.setConnection connection
        q.find()

    factory.$inject = [
      options.nameToTable(match.name)
    ]
    factory.$source = 'autogenerated by fragments-forge.newDataSelectResolver'
    factory.$match = match

    return {
      factory: factory
      name: name
    }

  resolver.$name = 'dataSelectResolver'
  return resolver

###################################################################################
# data insert

module.exports.parseDataInsert = (name) ->
  words = module.exports.splitCamelcase name

  unless 'insert' is words[0]
    return

  [table, withConnection] = module.exports.splitArray(
    words.slice(1)
    ['with', 'connection']
  )

  if table.length is 0
    return

  {
    name: module.exports.joinCamelcase(table)
    withConnection: withConnection?
  }

module.exports.newDataInsertResolver = (options = {}) ->
  options.matcher ?= module.exports.parseDataInsert
  options.nameToTable ?= (name) ->
    name + 'Table'
  options.nameToAllowedColumns ?= (name) ->
    name + 'InsertableColumns'

  resolver = (name, container, inner) ->
    result = inner name
    if result?
      return result

    match = options.matcher name
    unless match?
      return

    factory = (table, allowedColumns) ->
      (data, connection) ->
        query = table
        if match.withConnection
          unless connection?
            throw new Error "#{name} must be called with connection as argument number #{index+1}"
          query = query.setConnection connection
        query
          .allow(allowedColumns)
          .insert(data)

    factory.$inject = [
      options.nameToTable(match.name)
      options.nameToAllowedColumns(match.name)
    ]
    factory.$source = 'autogenerated by fragments-forge.newDataInsertResolver'
    factory.$match = match

    return {
      factory: factory
      name: name
    }

  resolver.$name = 'dataInsertResolver'
  return resolver

###################################################################################
# data update

module.exports.parseDataUpdate = (name) ->
  words = module.exports.splitCamelcase name

  unless 'update' is words[0]
    return

  [tableWhere, withConnection] = module.exports.splitArray(
    words.slice(1)
    ['with', 'connection']
  )

  [table, where...] = module.exports.splitArray tableWhere, 'where'

  if table.length is 0
    return

  # dont allow mass update without condition for security reasons
  if where.length is 0
    return

  {
    name: module.exports.joinCamelcase table
    where: where.map (x) -> module.exports.joinUnderscore x
    withConnection: withConnection?
  }

module.exports.newDataUpdateResolver = (options = {}) ->
  options.matcher ?= module.exports.parseDataUpdate
  options.nameToTable ?= (name) ->
    name + 'Table'
  options.nameToAllowedColumns ?= (name) ->
    name + 'UpdateableColumns'

  resolver = (name, container, inner) ->
    result = inner name
    if result?
      return result

    match = options.matcher name
    unless match?
      return

    factory = (table, allowedColumns) ->
      (data, args...) ->
        query = table
        index = 0
        match.where.forEach (x) ->
          condition = {}
          condition[x] = args[index++]
          query = query.where condition
        if match.withConnection
          connection = args[index]
          unless connection?
            throw new Error "#{name} must be called with connection as argument number #{index+1}"
          query = query.setConnection connection
        query
          .allow(allowedColumns)
          .update(data)

    factory.$inject = [
      options.nameToTable(match.name)
      options.nameToAllowedColumns(match.name)
    ]
    factory.$source = 'autogenerated by fragments-forge.newDataUpdateResolver'
    factory.$match = match

    return {
      factory: factory
      name: name
    }

  resolver.$name = 'dataUpdateResolver'
  return resolver

###################################################################################
# data delete

module.exports.parseDataDelete = (name) ->
  words = module.exports.splitCamelcase name

  unless 'delete' is words[0]
    return

  [tableWhere, withConnection] = module.exports.splitArray(
    words.slice(1)
    ['with', 'connection']
  )

  [table, where...] = module.exports.splitArray tableWhere, 'where'

  if table.length is 0
    return

  # dont allow mass update without condition for security reasons
  if where.length is 0
    return

  {
    name: module.exports.joinCamelcase table
    where: where.map (x) -> module.exports.joinUnderscore x
    withConnection: withConnection?
  }

module.exports.newDataDeleteResolver = (options = {}) ->
  options.matcher ?= module.exports.parseDataDelete
  options.nameToTable ?= (name) ->
    name + 'Table'

  resolver = (name, container, inner) ->
    result = inner name
    if result?
      return result

    match = options.matcher name
    unless match?
      return

    factory = (table) ->
      (args...) ->
        query = table
        index = 0
        match.where.forEach (x) ->
          condition = {}
          condition[x] = args[index++]
          query = query.where condition
        if match.withConnection
          connection = args[index]
          unless connection?
            throw new Error "#{name} must be called with connection as argument number #{index+1}"
          query = query.setConnection connection
        query.delete()

    factory.$inject = [
      options.nameToTable(match.name)
    ]
    factory.$source = 'autogenerated by fragments-forge.newDataDeleteResolver'
    factory.$match = match

    return {
      factory: factory
      name: name
    }

  resolver.$name = 'dataDeleteResolver'
  return resolver

###################################################################################
# alias:
# if a `name` is looked up that is a key in `aliasMap`
# then look up the associated value instead

module.exports.newAliasResolver = (aliasMap = {}) ->
  resolver = (name, container, inner) ->
    result = inner name
    if result?
      return result

    alias = aliasMap[name]

    unless alias?
      return

    inner alias

  resolver.$name = 'aliasResolver'
  return resolver

###################################################################################
# namespace:
# if `name` is looked up and its namespace
# is a key in `aliasToNamespaces`
# then look it up in all the namespaces in the associated
# value (which must be an array) instead

module.exports.newNamespaceResolver = (aliasToNamespaces = {}) ->
  resolver = (name, container, inner) ->
    # if the name is directly resolvable return it
    value = inner name
    if value?
      return value

    # otherwise try out namespace mappings

    parts = name.split '_'
    if parts.length is 1
      # common case (no namespace part)
      aliasPart = ''
      namePart = parts[0]
    else
      aliasPart = parts.slice(0, -1).join('_')
      namePart = parts[parts.length - 1]

    possibleNamespaces = aliasToNamespaces[aliasPart]

    unless possibleNamespaces?
      # common case (no mapping for namespace part)
      return

    unless Array.isArray possibleNamespaces
      throw new Error 'values in aliasToNamespaces must be arrays'

    results = []

    for namespace in possibleNamespaces
      do (namespace) ->
        # call inner multiple times with different ids
        mappedName = if namespace is ''
            namePart
          else
            [namespace, namePart].join('_')
        resolved = inner mappedName
        if resolved?
          results.push
            namespace: namespace
            mappedName: mappedName
            resolved: resolved

    return switch results.length
      when 0 then undefined
      when 1 then results[0].resolved
      else
        lines = [
          "ambiguity in namespace resolver."
          "\"#{name}\" maps to multiple resolvable names:"
        ]
        results.forEach (result) ->
          lines.push "#{result.mappedName} (#{aliasPart} -> #{result.namespace})"
        throw new Error lines.join('\n')

  resolver.$name = 'namespaceResolver'
  return resolver
